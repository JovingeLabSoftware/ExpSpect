---
title: "ExpSpect Analysis Example"
author: "Eric J. Kort"
date: "`r Sys.Date()`"
output: pdf_document
vignette: >
  %\VignetteIndexEntry{ExpSpect Analysis Example}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---
## Analysis of LINCS data with the ExpSpect package

### Preparing your environment

In order to complete this analysis, the level 4 dataset should be obtained from the [lincs project](https://docs.google.com/forms/d/1j6Vb_s4FrDodxoS3IDZsHWoVNrOnKNQbqwbwcW2a208/viewform).  In addition, the ExpSpect package requires the following packages: `R6`, `rhdf5`, `hgu133plus2.db`, `RCurl`, `RJSONIO`.

The expression data matrix is large (~120GB), and may be obtained using the s3cmd command line tool on Linux-like systems:

```
# configure s3cmd with your keys
s3cmd --configure

# now get the data file.  takes 30-60 minutes with a fast data connection.
s3cmd get  s3://data.lincscloud.org/l1000/level4/zspc_n1328098x22268.gctx
s3cmd get  s3://data.lincscloud.org/l1000/metadata/inst.info
```
The instance metadata from LINCS is provided as tab delimited file (inst.info) which is unwieldy to work with in an R session due to it size.  Therefore, the first step is to convert this file to hdf5 format using a helper function provided by the ExpSpect package:

```{r, eval=FALSE}
library(ExpSpect)
# adjust path below as needed.
lincs <- LINCS$new("/mnt/lincs/zspc_n1328098x22268.gctx")

# Generate hdf5 version of info file.  Only needs to be done once.
lincs$info2hdf5("/mnt/lincs/inst.info", "/desired/path/to/inst_info.gctx")

# now tell your lincs object where you saved the file just created
lincs$setInfoFile("/mnt/lincs/inst_info.gctx")
```

Now we are ready to begin.

### Feature reductions

First we will extract some signatures of interest from the LINCS expression data.  First we will restrict our analysis to a single cell line.  

```{r, eval=FALSE}
ha1e <- lincs$cellInfo('"cell_id":"HA1E"') 

```

The ExpSpect package provides a function to retrieve meta data from the info file. Here we extract the cell line identifier for each instance:

```{r, eval=FALSE}
cellids <- lincs$metadata(rows=4) 
ixnorm <- which(cellids %in% ha1e$cellid)
lincs$setCols(ixnorm, reset=TRUE)
```

Next let us restrict the analysis to instances where the perturbagen was a clinically relevant drug.  Again, the `ExpSpect` package contains a utility function that identifies drugs among the LINCS sperturbagens that are FDA approved for one or more indications.  Here we will identify the relevant `pertids` for the normal samples from above and extract the corresponding expression data for just the landmark (l1000) genes (as provided by the l1000Rows() method illustrated below).  Loading the data may take several minutes depending on size of the extracted data matrix.

```{r, eval=FALSE}
fdadrugs <- lincs$fdaDrugs()
pertids <- lincs$metadata(rows=2)
ixfda <- which(pertids %in% fdadrugs$pertid)
lincs$setCols(ixfda)
rows <- lincs$l1000Rows()
lincs$setRows(rows)

# 1778 x 6208 matrix ... this will take a few minutes...
datamatrix <- lincs$data()
```

### Reannotation

Although there are only roughly 980 landmark genes, the imputation that the LINCS project performs to reconstitute the entire genome from the landmark genes results in multiple probesets per entrez id in the level 4 dataset (even for the landmark genes), giving about 1700 rows of data for these 980 genes.  The resulting probeset ids are those corresponding to the Affymetrix HG U133 Plus 2.0 array. To facilitate comparison to other datasets from other platforms, it is useful to summarize this data down to a common gene identifier.  The ExpSpect package defines a utility function to summarize the data from probesets down to entrez id (as mapped by the hgu133plus2.db annotation package from Bioconductor).  The default summary method is `mean`, but you may supply an alternative summarization function if you wish.

This step is not necessary if you are going to be interrogating this data with gene expression data that also uses Affymetrix HG U133 Plus 2.0 probeset ids as the gene identifier (such as preprocessed data from GEO using that platform). 

```{r, eval=FALSE}
# takes a couple of minutes
datamatrix_entrez <- lincs$summarizeGenes(datamatrix, FUN=mean)
```

Converting to rank space is a brute force method for normalizing data.  While throwing away alot of information, it also eliminates the effects of any sources of error that effect only the magnitude of the data, not its order.  (For example, if a particular lab technician systematically added twice the input RNA s/he was supposed to, converting the resulting data to ranks column wise will remove that effect).  In particular, gene signature analysis often relies on a KS type statistic that is concerned only with the position of signatures genes in an ordered list, not the measured magnitude of those genes.  Converting our data to rank space is simple enough:

```{r, eval=FALSE}
rankmatrix_entrez <- apply(datamatrix_entrez, 2, order, decreasing=TRUE)
```

This dataset is now ready for interrogation against signatures of interest (such as gene expression profiles obtained from GEO).  

Next we will give an example of calculating enrichment scores based on the data we extracted above.  In this example, we will be comparing the imputed LINCS fold changes with pre-processed data from GEO.  The data we will be using was produced using the Affymetrix HG U133 Plus 2.0 arrays (GPL570), so we do not need to summarize to a different common gene id.  Instead we can use the datamatrix object from above directly (skipping the summarizeGenes step). NOTE: This example requires the GEOquery package from Bioconductor to fetch gene expression data from GEO).

## Identifying drug signatures with ExpSpect


```{r, eval=FALSE}
library(GEOquery)
GSE39339 <- getGEO('GSE39339', destdir="/mnt/lincs/GEO")
# grab the expression data for the samples of interest
GSE39339 <- exprs(GSE39339[[1]])[,1:8]
expct <- ExpSpect$new()
cor <- expct$calcScores(lincs, GSE39339[,5:8], GSE39339[,1:4], 'excos')

```
